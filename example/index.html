<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CRT Skin + p5 (Demo)</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <!-- Visible WebGL canvas (CRT skin) -->
  <canvas id="skin-stage"></canvas>

  <!-- Shaders embedded to avoid fetch/CORS issues -->
  <script id="crt-vert" type="x-shader/x-vertex">
  #version 300 es
  precision highp float;
  const vec2 verts[6] = vec2[6](
    vec2(-1.0,-1.0), vec2( 1.0,-1.0), vec2(-1.0, 1.0),
    vec2(-1.0, 1.0), vec2( 1.0,-1.0), vec2( 1.0, 1.0)
  );
  out vec2 vUV;
  void main() {
    vec2 p = verts[gl_VertexID];
    vUV = 0.5 * (p + 1.0);
    gl_Position = vec4(p, 0.0, 1.0);
  }
  </script>

  <script id="crt-frag" type="x-shader/x-fragment">
  #version 300 es
  precision highp float;
  in vec2 vUV;
  out vec4 fragColor;

  uniform sampler2D uTex;        // p5 content
  uniform sampler2D uPrevTex;    // previous frame (persistence)
  uniform vec2  uResolution;     // framebuffer size in pixels
  uniform float uTime;           // seconds
  uniform float uDPR;            // devicePixelRatio
  uniform vec2  uVirtRes;        // virtual raster grid (x,y)

  // Look controls
  uniform float uCurvature;      // 0..~0.2
  uniform float uRasterStrength; // 0..1
  uniform float uChroma;         // 0 mono .. 1 color
  uniform vec3  uTint;           // color multiplier (use 1,1,1 to keep colors)
  uniform float uBrightness;     // overall brightness
  uniform float uAmbient;        // center glow amount (0..0.2)
  uniform float uFlicker;        // tiny brightness wobble (0..0.03)
  uniform float uPersistence;    // 0..0.1 mix from previous frame
  uniform int   uRasterMode;     // 0=scanlines, 1=subpixel, 2=pixel

  // Utility
  float luma(vec3 c){ return dot(c, vec3(0.299, 0.587, 0.114)); }

  // Subtle barrel distortion around center
  vec2 barrel(vec2 uv, float k){
    vec2 cc = uv - 0.5;
    float d = dot(cc, cc) * k;
    return uv - cc * (1.0 + d) * d;
  }

  // Scanline-only raster (horizontal lines)
  vec3 raster_scanline(vec2 screenUV, vec3 texel, vec2 virtRes){
    vec2 coords = fract(screenUV * virtRes) * 2.0 - 1.0;
    float mask = 1.0 - abs(coords.y);
    vec3 hi = ((1.0 + 0.30) - (0.2 * texel)) * texel;
    vec3 lo = ((1.0 - 0.30) + (0.1 * texel)) * texel;
    return mix(texel, mix(lo, hi, mask), uRasterStrength);
  }

  // Subpixel triads along X + scanlines
  vec3 raster_subpixel(vec2 screenUV, vec3 texel, vec2 virtRes){
    float PI = 3.14159265359;
    vec2 omega = PI * 2.0 * virtRes;
    vec2 ang = screenUV * omega;
    const float SUBPIXELS = 3.0;
    vec3 offs = vec3(PI) * vec3(0.5, 0.5 - 2.0/3.0, 0.5 - 4.0/3.0);
    vec3 xf = (SUBPIXELS + sin(ang.x + offs)) / (SUBPIXELS + 1.0);
    vec3 t = texel * xf;
    vec2 coords = fract(screenUV * virtRes) * 2.0 - 1.0;
    float mask = 1.0 - abs(coords.y);
    vec3 hi = ((1.0 + 0.30) - (0.2 * t)) * t;
    vec3 lo = ((1.0 - 0.30) + (0.1 * t)) * t;
    vec3 ras = mix(lo, hi, mask);
    return mix(texel, ras, uRasterStrength);
  }

  // Pixel-cell style raster
  vec3 raster_pixel(vec2 screenUV, vec3 texel, vec2 virtRes){
    vec2 coords = fract(screenUV * virtRes) * 2.0 - 1.0;
    coords *= coords; // round cells
    float mask = clamp(1.0 - coords.x - coords.y, 0.0, 1.0);
    vec3 hi = ((1.0 + 0.30) - (0.2 * texel)) * texel;
    vec3 lo = ((1.0 - 0.30) + (0.1 * texel)) * texel;
    vec3 ras = mix(lo, hi, mask);
    return mix(texel, ras, uRasterStrength);
  }

  // Hash noise based on pixel coords/time
  float hash(vec2 p){
    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
    return fract(sin(p.x+p.y) * 43758.5453);
  }

  void main(){
    // Convert to physical pixel coords
    vec2 fragPx = (vUV * uResolution) / uDPR;
    vec2 uv = barrel(vUV, uCurvature);

    // Safe border (outside tube)
    if(any(lessThan(uv, vec2(0.0))) || any(greaterThan(uv, vec2(1.0)))){
      fragColor = vec4(0.0,0.0,0.0,1.0); return;
    }

    // Sample source
    vec3 col = texture(uTex, uv).rgb;

    // Chroma/tint
    float g = luma(col);
    col = uTint * mix(vec3(g), col, uChroma);

    // Rasterization in screen space (pixel-locked via uVirtRes)
    vec3 ras;
    if(uRasterMode == 0)      ras = raster_scanline(vUV, col, uVirtRes);
    else if(uRasterMode == 1) ras = raster_subpixel(vUV, col, uVirtRes);
    else                      ras = raster_pixel(vUV, col, uVirtRes);
    col = ras;

    // Ambient center glow
    vec2 c = uv - 0.5;
    float vign = smoothstep(0.9, 0.2, dot(c,c));
    float ambient = mix(1.0, 1.0 + uAmbient, 1.0 - vign);
    col *= ambient;

    // Flicker (very small)
    float f = 1.0 + (hash(fragPx + uTime*120.0) - 0.5) * (uFlicker*2.0);
    col *= f;

    // Persistence (blend previous frame a touch)
    vec3 prev = texture(uPrevTex, vUV).rgb;
    col = mix(col, max(col, prev), uPersistence);

    // Tiny grain
    col *= 1.0 + (hash(fragPx + uTime*10.0) - 0.5) * 0.02;

    // Brightness
    col *= uBrightness;

    fragColor = vec4(col, 1.0);
  }
  </script>

  <!-- p5 from CDN -->
  <script src="https://unpkg.com/p5@1.9.0/lib/p5.min.js"></script>
  <!-- Minimal p5 logic (static circle demo) -->
  <script src="js/logic/sketch.js"></script>
  <!-- WebGL skin glue -->
  <script src="js/skin.js" type="module"></script>
</body>
</html>
