<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CRT Skin + p5 (Single File)</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #000; }
    #skin-stage { position: fixed; inset: 0; width: 100vw; height: 100vh; display: block; }
  </style>
</head>
<body>
  <canvas id="skin-stage"></canvas>

  <!-- Shaders embedded -->
  <script id="crt-vert" type="x-shader/x-vertex">#version 300 es
  precision highp float;
  const vec2 verts[6] = vec2[6](
    vec2(-1.0,-1.0), vec2( 1.0,-1.0), vec2(-1.0, 1.0),
    vec2(-1.0, 1.0), vec2( 1.0,-1.0), vec2( 1.0, 1.0)
  );
  out vec2 vUV;
  void main() {
    vec2 p = verts[gl_VertexID];
    vUV = 0.5 * (p + 1.0);
    gl_Position = vec4(p, 0.0, 1.0);
  }
  </script>

  <script id="crt-frag" type="x-shader/x-fragment">#version 300 es
  precision highp float;
  in vec2 vUV; out vec4 fragColor;
  uniform sampler2D uTex, uPrevTex;
  uniform vec2  uResolution, uVirtRes;
  uniform float uTime, uDPR, uCurvature, uRasterStrength, uChroma, uBrightness, uAmbient, uFlicker, uPersistence;
  uniform vec3  uTint;
  uniform int   uRasterMode;
  float luma(vec3 c){ return dot(c, vec3(0.299, 0.587, 0.114)); }
  vec2 barrel(vec2 uv, float k){ vec2 cc = uv - 0.5; float d = dot(cc, cc) * k; return uv - cc * (1.0 + d) * d; }
  vec3 raster_scanline(vec2 suv, vec3 texel, vec2 vres){
    vec2 coords = fract(suv * vres) * 2.0 - 1.0;
    float mask = 1.0 - abs(coords.y);
    vec3 hi = ((1.0 + 0.30) - (0.2 * texel)) * texel;
    vec3 lo = ((1.0 - 0.30) + (0.1 * texel)) * texel;
    return mix(texel, mix(lo, hi, mask), uRasterStrength);
  }
  vec3 raster_subpixel(vec2 suv, vec3 texel, vec2 vres){
    float PI = 3.14159265359;
    vec2 omega = PI * 2.0 * vres;
    vec2 ang = suv * omega;
    const float SUBPIXELS = 3.0;
    vec3 offs = vec3(PI) * vec3(0.5, 0.5 - 2.0/3.0, 0.5 - 4.0/3.0);
    vec3 xf = (SUBPIXELS + sin(ang.x + offs)) / (SUBPIXELS + 1.0);
    vec3 t = texel * xf;
    vec2 coords = fract(suv * vres) * 2.0 - 1.0;
    float mask = 1.0 - abs(coords.y);
    vec3 hi = ((1.0 + 0.30) - (0.2 * t)) * t;
    vec3 lo = ((1.0 - 0.30) + (0.1 * t)) * t;
    vec3 ras = mix(lo, hi, mask);
    return mix(texel, ras, uRasterStrength);
  }
  vec3 raster_pixel(vec2 suv, vec3 texel, vec2 vres){
    vec2 coords = fract(suv * vres) * 2.0 - 1.0;
    coords *= coords; float mask = clamp(1.0 - coords.x - coords.y, 0.0, 1.0);
    vec3 hi = ((1.0 + 0.30) - (0.2 * texel)) * texel;
    vec3 lo = ((1.0 - 0.30) + (0.1 * texel)) * texel;
    vec3 ras = mix(lo, hi, mask);
    return mix(texel, ras, uRasterStrength);
  }
  float hash(vec2 p){ p = vec2(dot(p, vec2(127.1,311.7)), dot(p, vec2(269.5,183.3))); return fract(sin(p.x+p.y)*43758.5453); }
  void main(){
    vec2 fragPx = (vUV * uResolution) / uDPR;
    vec2 uv = barrel(vUV, uCurvature);
    if(any(lessThan(uv, vec2(0.0))) || any(greaterThan(uv, vec2(1.0)))){ fragColor = vec4(0.0); return; }
    vec3 col = texture(uTex, uv).rgb;
    float g = luma(col);
    col = uTint * mix(vec3(g), col, uChroma);
    vec3 ras;
    if(uRasterMode==0) ras = raster_scanline(vUV, col, uVirtRes);
    else if(uRasterMode==1) ras = raster_subpixel(vUV, col, uVirtRes);
    else ras = raster_pixel(vUV, col, uVirtRes);
    col = ras;
    vec2 c = uv - 0.5; float vign = smoothstep(0.9, 0.2, dot(c,c)); float ambient = mix(1.0, 1.0 + uAmbient, 1.0 - vign); col *= ambient;
    float f = 1.0 + (hash(fragPx + uTime*120.0) - 0.5) * (uFlicker*2.0); col *= f;
    vec3 prev = texture(uPrevTex, vUV).rgb; col = mix(col, max(col, prev), uPersistence);
    col *= 1.0 + (hash(fragPx + uTime*10.0) - 0.5) * 0.02;
    col *= uBrightness;
    fragColor = vec4(col, 1.0);
  }
  </script>

  <!-- p5 from CDN -->
  <script src="https://unpkg.com/p5@1.9.0/lib/p5.min.js"></script>

  <!-- Inline p5 logic (offscreen graphics) -->
  <script>
  (function(){
    let gfx = null;
    let w = 640, h = 400;
    new p5((p) => {
      p.setup = () => {
        p.pixelDensity(1);
        gfx = p.createGraphics(w, h);
        gfx.pixelDensity(1);
        p.createCanvas(1,1);
        p.noLoop();
      };
      p.draw = () => {};
    });
    function drawGfx(){
      if (!gfx) { requestAnimationFrame(drawGfx); return; }
      const t = performance.now() * 0.001;
      gfx.push();
      gfx.clear();
      gfx.background(8, 10, 14);
      gfx.noStroke();
      gfx.fill(240, 250, 255);
      const r = 60 + Math.sin(t*2.0) * 6.0;
      gfx.circle(gfx.width/2, gfx.height/2, r);
      gfx.fill(180);
      gfx.textAlign(gfx.CENTER, gfx.TOP);
      gfx.textSize(16);
      gfx.text("p5 â†’ CRT skin", gfx.width/2, 10);
      gfx.pop();
      requestAnimationFrame(drawGfx);
    }
    requestAnimationFrame(drawGfx);
    window.getP5Canvas = function(){ return gfx ? gfx.elt : null; };
    window.getP5Size = function(){ return gfx ? {w: gfx.width, h: gfx.height} : {w: 640, h: 400}; };
  })();
  </script>

  <!-- Inline WebGL skin (no module, no external fetch) -->
  <script>
  (function(){
    const skin = document.getElementById('skin-stage');
    const gl = skin.getContext('webgl2', { alpha: false, antialias: false });
    if(!gl){ alert('WebGL2 not available.'); return; }

    function getShaderSource(id){ return document.getElementById(id).textContent.trim(); }
    function compile(gl, type, src){
      const sh = gl.createShader(type); gl.shaderSource(sh, src); gl.compileShader(sh);
      if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){ console.error(gl.getShaderInfoLog(sh)); throw new Error('Shader compile failed'); }
      return sh;
    }
    function programFromSources(gl, vsSrc, fsSrc){
      const vs = compile(gl, gl.VERTEX_SHADER, vsSrc);
      const fs = compile(gl, gl.FRAGMENT_SHADER, fsSrc);
      const prog = gl.createProgram();
      gl.attachShader(prog, vs); gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){ console.error(gl.getProgramInfoLog(prog)); throw new Error('Program link failed'); }
      return prog;
    }
    function makeFullscreenVAO(gl){
      const vao = gl.createVertexArray(); gl.bindVertexArray(vao); gl.bindVertexArray(null); return vao;
    }
    function createRenderTexture(gl, w, h){
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      return tex;
    }
    function createFramebuffer(gl, tex){
      const fb = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      return fb;
    }

    const program = programFromSources(gl, getShaderSource('crt-vert'), getShaderSource('crt-frag'));
    const vao = makeFullscreenVAO(gl);
    gl.useProgram(program);
    const u = {
      uTex: gl.getUniformLocation(program,'uTex'),
      uPrevTex: gl.getUniformLocation(program,'uPrevTex'),
      uResolution: gl.getUniformLocation(program,'uResolution'),
      uTime: gl.getUniformLocation(program,'uTime'),
      uDPR: gl.getUniformLocation(program,'uDPR'),
      uVirtRes: gl.getUniformLocation(program,'uVirtRes'),
      uCurvature: gl.getUniformLocation(program,'uCurvature'),
      uRasterStrength: gl.getUniformLocation(program,'uRasterStrength'),
      uChroma: gl.getUniformLocation(program,'uChroma'),
      uTint: gl.getUniformLocation(program,'uTint'),
      uBrightness: gl.getUniformLocation(program,'uBrightness'),
      uAmbient: gl.getUniformLocation(program,'uAmbient'),
      uFlicker: gl.getUniformLocation(program,'uFlicker'),
      uPersistence: gl.getUniformLocation(program,'uPersistence'),
      uRasterMode: gl.getUniformLocation(program,'uRasterMode'),
    };

    let DPR = 1;
    const ping = { texA:null, texB:null, fbA:null, fbB:null, flip:false };
    function resize(){
      DPR = Math.min(2, window.devicePixelRatio || 1);
      const cssW = Math.floor(window.innerWidth);
      const cssH = Math.floor(window.innerHeight);
      skin.style.width = cssW + 'px';
      skin.style.height = cssH + 'px';
      skin.width = Math.floor(cssW * DPR);
      skin.height = Math.floor(cssH * DPR);
      gl.viewport(0, 0, skin.width, skin.height);
      if(ping.texA){ gl.deleteTexture(ping.texA); gl.deleteTexture(ping.texB); gl.deleteFramebuffer(ping.fbA); gl.deleteFramebuffer(ping.fbB); }
      ping.texA = createRenderTexture(gl, skin.width, skin.height);
      ping.texB = createRenderTexture(gl, skin.width, skin.height);
      ping.fbA = createFramebuffer(gl, ping.texA);
      ping.fbB = createFramebuffer(gl, ping.texB);
    }
    window.addEventListener('resize', resize); resize();

    const srcTex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, srcTex);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    const params = {
      curvature: 0.10,
      rasterStrength: 0.45,
      chroma: 1.0,
      tint: [1.0, 1.0, 1.0],
      brightness: 1.0,
      ambient: 0.05,
      flicker: 0.01,
      persistence: 0.04,
      rasterMode: 0,
    };

    let start = performance.now();
    function frame(now){
      const p5Canvas = window.getP5Canvas && window.getP5Canvas();
      if(p5Canvas){
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, srcTex);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, p5Canvas);
      }
      const prevTex = ping.flip ? ping.texB : ping.texA;
      const currFB  = ping.flip ? ping.fbA  : ping.fbB;
      ping.flip = !ping.flip;

      gl.bindFramebuffer(gl.FRAMEBUFFER, currFB);
      gl.useProgram(program);
      gl.bindVertexArray(vao);

      gl.uniform1i(u.uTex, 0);
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, prevTex);
      gl.uniform1i(u.uPrevTex, 1);

      gl.uniform2f(u.uResolution, skin.width, skin.height);
      gl.uniform1f(u.uTime, (now - start) * 0.001);
      gl.uniform1f(u.uDPR, DPR);
      gl.uniform2f(u.uVirtRes, skin.width / DPR, skin.height / DPR);
      gl.uniform1f(u.uCurvature, params.curvature);
      gl.uniform1f(u.uRasterStrength, params.rasterStrength);
      gl.uniform1f(u.uChroma, params.chroma);
      gl.uniform3f(u.uTint, params.tint[0], params.tint[1], params.tint[2]);
      gl.uniform1f(u.uBrightness, params.brightness);
      gl.uniform1f(u.uAmbient, params.ambient);
      gl.uniform1f(u.uFlicker, params.flicker);
      gl.uniform1f(u.uPersistence, params.persistence);
      gl.uniform1i(u.uRasterMode, params.rasterMode);

      gl.drawArrays(gl.TRIANGLES, 0, 6);

      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, currFB);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      gl.blitFramebuffer(0,0,skin.width,skin.height, 0,0,skin.width,skin.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

    // Expose quick presets
    window.CRTParams = {
      setRasterMode: (m)=> params.rasterMode = m|0,
      setTint: (r,g,b)=> { params.tint = [r,g,b]; },
      amber: ()=> { params.tint=[1.0,0.73,0.2]; params.chroma=0.35; },
      green: ()=> { params.tint=[0.65,1.0,0.65]; params.chroma=0.35; },
      rgb:   ()=> { params.tint=[1.0,1.0,1.0]; params.chroma=1.0; },
    };
  })();
  </script>
</body>
</html>
